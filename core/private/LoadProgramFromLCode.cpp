//
// Created by Io on 13/04/2018.
//

#include "LoadProgramFromLCode.hpp"

namespace lcode
{
    namespace antlr
    {
        unsigned int stoui(std::string const& text, std::size_t* consumed)
        {
            return static_cast<unsigned int>(std::stoul(text, consumed));
        }

        std::string getTokenIdentifier(antlr4::Token* const token)
        {
            return token->getText();
        }

        template <class IT>
        std::vector<std::string> getTokenIdentifiers(IT begin, IT end)
        {
            std::vector<std::string> identifiers(std::distance(begin, end));

            std::generate(identifiers.begin(), identifiers.end(), [&begin] ()
            {
                auto text = (*begin)->getText();

                ++begin;
                return text;
            });

            return identifiers;
        }

        Program::Error errorFromToken(antlr4::Token* token, std::string const& message)
        {
            Program::Error error;

            error.charIndex = token->getCharPositionInLine();
            error.line = token->getLine();
            error.message = message;
            return error;
        }
    }

    Program::Content Program::LoadFromLCode::load()
    {
        antlr4::ANTLRInputStream inputStream(m_lcode);
        LSystemLexer lexer(&inputStream);
        antlr4::CommonTokenStream tokenStream(&lexer);
        LSystemParser parser(&tokenStream);
        antlr4::tree::ParseTreeWalker treeWalker;

        lexer.removeErrorListener(&antlr4::ConsoleErrorListener::INSTANCE);
        lexer.addErrorListener(this);
        parser.removeErrorListener(&antlr4::ConsoleErrorListener::INSTANCE);
        parser.addErrorListener(this);

        // Parse!

        auto* const tree = parser.program();

        treeWalker.walk(this, tree);

        return m_parseResult;
    }

    template <class T, class F>
    Optional<T> Program::LoadFromLCode::toT(antlr4::Token* const token, std::vector<Error>& errors, F f)
    {
        std::size_t digitUsed = 0u;
        auto const text = token->getText();
        Optional<T> result;

        T tempResult = f(text, &digitUsed);

        if (digitUsed != text.size())
        {
            Program::Error error = antlr::errorFromToken(token, "Invalid input: '" + text + "'");

            errors.emplace_back(std::move(error));
        }
        else
        {
            result.assign(tempResult);
        }

        return result;
    }

    void Program::LoadFromLCode::enterAxiom(LSystemParser::AxiomContext* context)
    {
        auto const tokens = context->getTokens(LSystemParser::Identifier);

        for (auto* const token : tokens)
        {
            auto const tokenText = token->getText();
            auto const module = m_table.createModule(tokenText);

            if (module.isNull())
            {
                Program::Error error = antlr::errorFromToken(token->getSymbol(),
                                                             "Unknown module identifier '" + tokenText + "'");

                m_parseResult.errors.emplace_back(error);
            } else
            {
                m_parseResult.axiom.emplace_back(std::move(module));
            }
        }
    }

    void Program::LoadFromLCode::enterTransformation(LSystemParser::TransformationContext* context)
    {
        // First token is always the 'replaced token' and all the next tokens are the 'replacement tokens'.
        // Here parser generated by ANTLR should have failed if something was not formatted correctly so
        // it must be at least 2 tokens.
        auto const tokens = context->getTokens(LSystemParser::Identifier);

        // Surprisingly it's possible this condition be not meet!
        // In case of error ANTLR continue. In order to avoid any problems related to
        // the number of tokens we skip all the process if this condition is not meet.
        if (tokens.size() > 1u)
        {
            auto replacedIdentifier = m_table.createModule(tokens.front()->getText());
            auto replacementIdentifiers = m_table.createModules(antlr::getTokenIdentifiers(
                    tokens.begin() + 1, tokens.end()));

            m_parseResult.rewriteRules.emplace(std::move(replacedIdentifier), std::move(replacementIdentifiers));
        }
    }

    void Program::LoadFromLCode::enterIterations(LSystemParser::IterationsContext* context)
    {
        auto const tokens = context->getTokens(LSystemParser::Integer);

        // TODO: resolve expression here instead of just parsing a simple number
        if (tokens.size() == 1u)
        {
            m_parseResult.iterations = toT<unsigned int>(tokens.front()->getSymbol(), m_parseResult.errors, antlr::stoui);
        }
    }

    void Program::LoadFromLCode::enterDistance(LSystemParser::DistanceContext* context)
    {
        auto const tokens = context->getTokens(LSystemParser::Float);

        // TODO: resolve expression here instead of just parsing a simple number
        if (tokens.size() == 1u)
        {
            auto const value = std::stod(antlr::getTokenIdentifier(tokens.front()->getSymbol()));

            if (value >= 0)
            {
                m_parseResult.distance = value;
            } else
            {
                auto const text = tokens.front()->getText();
                Program::Error error = antlr::errorFromToken(tokens.front()->getSymbol(),
                                                             "Invalid distance: '" + text + "'");

                m_parseResult.errors.emplace_back(std::move(error));
            }
        }
    }

    void Program::LoadFromLCode::enterAngle(LSystemParser::AngleContext* context)
    {
        auto const tokens = context->getTokens(LSystemParser::Float);

        // TODO: resolve expression here instead of just parsing a simple number
        if (tokens.size() == 1u)
        {
            m_parseResult.angle = std::stod(tokens.front()->getText());
        }
    }

    void Program::LoadFromLCode::enterInitial_angle(LSystemParser::Initial_angleContext* context)
    {
        auto const tokens = context->getTokens(LSystemParser::Float);

        // TODO: resolve expression here instead of just parsing a simple number
        if (tokens.size() == 1u)
        {
            m_parseResult.initialAngle = std::stod(tokens.front()->getText());
        }
    }

    void
    Program::LoadFromLCode::syntaxError(antlr4::Recognizer*, antlr4::Token*, size_t line, size_t charPositionInLine, const std::string& msg, std::exception_ptr)
    {
        Error error;

        error.charIndex = charPositionInLine;
        error.line = line;
        error.message = msg;
        m_parseResult.errors.emplace_back(std::move(error));
    }

    void
    Program::LoadFromLCode::reportAmbiguity(antlr4::Parser*, antlr4::dfa::DFA const&, size_t, size_t, bool, const antlrcpp::BitSet&, antlr4::atn::ATNConfigSet*)
    {
    }

    void
    Program::LoadFromLCode::reportAttemptingFullContext(antlr4::Parser*, antlr4::dfa::DFA const&, size_t, size_t, const antlrcpp::BitSet&, antlr4::atn::ATNConfigSet*)
    {
    }

    void
    Program::LoadFromLCode::reportContextSensitivity(antlr4::Parser*, antlr4::dfa::DFA const&, size_t, size_t, size_t, antlr4::atn::ATNConfigSet*)
    {
    }
}