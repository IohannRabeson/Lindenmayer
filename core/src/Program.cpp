//
// Created by Io on 11/04/2018.
//

#include "Program.hpp"

#include <generated/LSystemParser.h>
#include <generated/LSystemLexer.h>
#include <generated/LSystemBaseListener.h>

#include <antlr4-runtime.h>

#include <algorithm>

namespace lcode
{
    namespace antlr
    {
        std::string getTokenIdentifier(antlr4::Token* const token)
        {
            return token->getText();
        }

        template <class IT>
        std::vector<std::string> getTokenIdentifiers(IT begin, IT end)
        {
            std::vector<std::string> identifiers(std::distance(begin, end));

            std::generate(identifiers.begin(), identifiers.end(), [&begin] ()
            {
                auto text = (*begin)->getText();

                ++begin;
                return text;
            });

            return identifiers;
        }
    }

    std::vector<Program::Error> Program::load(ALoader&& loader)
    {
        auto result = loader.load();

        m_axiom = std::move(result.axiom);
        m_rewriteRules = std::move(result.rewriteRules);
        return result.errors;
    }

    Program::ALoader::~ALoader() = default;

    class Program::LoadFromLCode : public ALoader,
                                   public LSystemBaseListener,
                                   public antlr4::ANTLRErrorListener
    {
        std::string const& m_lcode;
        ModuleTable const& m_table;
        Modules m_axiom;
        RewriteRules m_rules;
        std::vector<Error> m_errors;
    public:
        LoadFromLCode(std::string const& lcode, ModuleTable const& table)
        : m_lcode(lcode)
        , m_table(table)
        {
        }

        ParseResult load() override
        {
            antlr4::ANTLRInputStream inputStream(m_lcode);
            LSystemLexer lexer(&inputStream);
            antlr4::CommonTokenStream tokenStream(&lexer);
            LSystemParser parser(&tokenStream);
            antlr4::tree::ParseTreeWalker treeWalker;

            lexer.removeErrorListener(&antlr4::ConsoleErrorListener::INSTANCE);
            lexer.addErrorListener(this);
            parser.removeErrorListener(&antlr4::ConsoleErrorListener::INSTANCE);
            parser.addErrorListener(this);

            // Parse!

            auto* const tree = parser.program();

            treeWalker.walk(this, tree);

            ParseResult result;

            result.axiom = std::move(m_axiom);
            result.rewriteRules = std::move(m_rules);
            result.errors = std::move(m_errors);
            return result;
        }

        void enterAxiom(LSystemParser::AxiomContext* context) override
        {
            auto const tokens = context->getTokens(LSystemParser::Identifier);

            for (auto* const token : tokens)
            {
                auto const tokenText = token->getText();
                auto const module = m_table.createModule(tokenText);

                if (module.isNull())
                {
                    Program::Error error;

                    error.message = "Unknown module identifier '" + tokenText + "'";
                    error.charIndex = token->getSymbol()->getCharPositionInLine();
                    error.line = token->getSymbol()->getLine();
                    m_errors.emplace_back(error);
                }
                else
                {
                    m_axiom.emplace_back(std::move(module));
                }
            }
        }

        void enterTransformation(LSystemParser::TransformationContext* context) override
        {
            // First token is always the 'replaced token' and all the next tokens are the 'replacement tokens'.
            // Here parser generated by ANTLR should have failed if something was not formatted correctly so
            // it must be at least 2 tokens.
            auto const tokens = context->getTokens(LSystemParser::Identifier);

            // Surprisingly it's possible this condition be not meet!
            // In case of error ANTLR continue. In order to avoid any problems related to
            // the number of tokens we skip all the process if this condition is not meet.
            if( tokens.size() > 1u )
            {
                auto replacedIdentifier = m_table.createModule(tokens.front()->getText());
                auto replacementIdentifiers = m_table.createModules(antlr::getTokenIdentifiers(tokens.begin() + 1, tokens.end()));

                m_rules.emplace(std::move(replacedIdentifier), std::move(replacementIdentifiers));
            }
        }

        void syntaxError(antlr4::Recognizer*, antlr4::Token*,
                size_t line, size_t charPositionInLine, const std::string& msg, std::exception_ptr) override
        {
            Error error;

            error.charIndex = charPositionInLine;
            error.line = line;
            error.message = msg;
            m_errors.emplace_back(std::move(error));
        }

        void
        reportAmbiguity(antlr4::Parser*, antlr4::dfa::DFA const&, size_t, size_t, bool, const antlrcpp::BitSet&,
                antlr4::atn::ATNConfigSet*) override
        {
        }

        void
        reportAttemptingFullContext(antlr4::Parser*, antlr4::dfa::DFA const&, size_t, size_t, const antlrcpp::BitSet&,
                antlr4::atn::ATNConfigSet*) override
        {
        }

        void
        reportContextSensitivity(antlr4::Parser*, antlr4::dfa::DFA const&, size_t, size_t, size_t,
                antlr4::atn::ATNConfigSet*) override
        {
        }
    };

    std::vector<Program::Error> Program::loadFromLCode(std::string const& lcode, ModuleTable const& table)
    {
        return load(LoadFromLCode(lcode, table));
    }

    Modules Program::rewrite(unsigned int const iterations) const
    {
        return rewrited(m_rewriteRules, m_axiom, iterations);
    }
}